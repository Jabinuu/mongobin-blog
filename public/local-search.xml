<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JS的各种类型继承模式总结</title>
    <link href="/2023/05/07/inherit/"/>
    <url>/2023/05/07/inherit/</url>
    
    <content type="html"><![CDATA[<h1 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h1><ul><li>原型式继承就是<code>Object.create()</code>的实现原理。</li><li>原型式继承非常适用于不需要单独创建构造函数，但仍需要在对象实例之间共享信息的场合。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">create</span>(<span class="hljs-params">o</span>)&#123;<br>   <span class="hljs-comment">// 创建一个临时构造函数，将传入的对象赋值给这个构造函数的原型</span><br>   <span class="hljs-keyword">function</span> <span class="hljs-title function_">F</span>(<span class="hljs-params"></span>)&#123;&#125;  <br>   F.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = o<br>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>()<br> &#125;<br> <span class="hljs-keyword">let</span> sup = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;jiabin&#x27;</span>&#125;;<br> <span class="hljs-keyword">let</span> sub = <span class="hljs-title function_">create</span>(sup);<br> sub.<span class="hljs-property">age</span> = <span class="hljs-number">23</span><br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sub);<br></code></pre></td></tr></table></figure><p><img src="http://182.44.49.100:34/images/image-20230507160253096.png" alt="image-20230507160253096"></p><blockquote><p>记住<code>create()</code>这个函数，下文的代码中会反复用到</p></blockquote><h1 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createAnother</span>(<span class="hljs-params">o</span>)&#123;<br>  <span class="hljs-keyword">let</span> clone = <span class="hljs-title function_">create</span>(o);   <span class="hljs-comment">// 调用函数创建一个新的实现继承的对象</span><br>  clone.<span class="hljs-property">sayHi</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;   <span class="hljs-comment">// 以某种方式增强这个对象</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hello&#x27;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> clone<br>&#125;<br></code></pre></td></tr></table></figure><p>与原型式继承比较接近的是寄生式继承，它的思想是在原型式继承的基础上，以某种方式对子对象进行改造（增强）。</p><h3 id="寄生式-vs-原型式"><a href="#寄生式-vs-原型式" class="headerlink" title="寄生式 vs 原型式"></a>寄生式 vs 原型式</h3><ul><li><p>与原型式继承的不同之处是，寄生式继承不仅实现了实例之间的继承关系，并且增强了子实例。</p></li><li><p>寄生式与原型式都适合于不需要构造函数，只需关注对象实例的场景</p></li></ul><h1 id="盗用构造函数"><a href="#盗用构造函数" class="headerlink" title="盗用构造函数"></a>盗用构造函数</h1><p>由于原型链的原因，以上两种继承方式创建的对象之间是会共享引用类型的属性的，这导致不同的对象之间无法拥有自己独立的数据。</p><p>通过调用父类构造函数的的call / apply函数，可以实现夫类型构造函数的借用。使得子类型的构造函数也能创建独立的父类型数据。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">SupType</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;jiabin&#x27;</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = <span class="hljs-number">23</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>)&#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hello!&#x27;</span>)<br>  &#125;<br>&#125; <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">SubType</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-title class_">SupType</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>)<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">job</span> = <span class="hljs-string">&#x27;worker&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>由<code>SubType</code>构造函数创建的对象也包含<code>SupType</code>构造函数的属性，并且是对象本身所有的。但缺点是不能重用父类型的方法（大量同名同作用，但内存地址不相同的函数）</p><h1 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">SupType</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;jiabin&#x27;</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = <span class="hljs-number">23</span><br>  &#125;<br>  <span class="hljs-title class_">SupType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>  &#125;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">SubType</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">job</span>=<span class="hljs-string">&#x27;programmer&#x27;</span><br>    <span class="hljs-title class_">SupType</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>)    <span class="hljs-comment">// 盗用父类构造函数</span><br>  &#125;<br>  <span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SupType</span>();     <span class="hljs-comment">// 第二次调用父类构造函数</span><br>  <span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">SubType</span>   <span class="hljs-comment">// 修正子类型原型的constructor值，保持原型链不变，使得instanceof和isPropertyOf()正常有效</span><br>  sub = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubType</span>()<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sub);<br></code></pre></td></tr></table></figure><p><img src="http://182.44.49.100:34/images/image-20230507160643061.png" alt="image-20230507160643061"></p><p>综合了原型链和盗用构造函数，使得子类型的实例既可以实现方法重用，又可以拥有自己的属性数据</p><h1 id="寄生式组合继承"><a href="#寄生式组合继承" class="headerlink" title="寄生式组合继承"></a>寄生式组合继承</h1><p>组合继承实现了基本的方法重用和独立属性，但他存在着效率问题。</p><ul><li>最主要的效率问题是父类型的构造函数被调用了两次，一次是在盗用构造函数时，另一次是在给子类型构造函数的原型赋值时。实际上，对于第二次调用，目的只是为了重写子类型的原型，完全不需要调用父类型构造函数来实例化一个父类对象这么麻烦，可以通过创建一个继承父类型的简单对象（寄生于父类型原型的寄生虫），然后增强这个对象（寄生虫），实现子类型对父类型的继承</li><li>其次是子类型构造函数的原型中存在着冗余的父类型的属性。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">SupType1</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;jiabin&#x27;</span>;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = <span class="hljs-number">23</span>;<br>&#125;<br><br><span class="hljs-comment">// 在父类型的原型上声明可让子类型重用的方法</span><br><span class="hljs-title class_">SupType1</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getAge</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">SubType1</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-title class_">SupType</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>)<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">job</span> = <span class="hljs-string">&#x27;worker&#x27;</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">inheritSupType</span>(<span class="hljs-params">SupType,SubType</span>)&#123;<br>  <span class="hljs-keyword">let</span> prototype = <span class="hljs-title function_">create</span>(<span class="hljs-title class_">SupType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);  <span class="hljs-comment">// 创建一个寄生虫对象，它就是子类型的原型</span><br>  prototype.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">SubType</span>    <span class="hljs-comment">// 修正寄生虫对象的constructor的值</span><br>  <span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = prototype      <span class="hljs-comment">// 给子类型的原型重新赋值</span><br>&#125;<br><span class="hljs-title function_">inheritSupType</span>(<span class="hljs-title class_">SupType1</span>,<span class="hljs-title class_">SubType1</span>);<br><br>sub = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubType1</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sub);<br><br></code></pre></td></tr></table></figure><p><img src="http://182.44.49.100:34/images/image-20230507162321625.png" alt="image-20230507162321625"></p><p>可以看到<strong>没有了冗余</strong>的父类型属性，而且不同的子类型示例<strong>可以重用</strong>同一个父类型的方法。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>原型式继承和寄生式继承适用于继承某个对象实例的场景。创建的对象存在数据共享的问题</li><li>在子类型构造函数中盗用父类型构造函数，解决了数据共享问题，但是引发方法不能重用的问题</li><li>组合继承，组合了盗用构造函数和原型链，解决了上述两个问题，但存在效率问题和冗余父类型属性</li><li>寄生式组合继承解决了组合继承的效率问题、避免了冗余对的父类属性，是最佳的类型继承范式，是ES6 extends关键字的实现原理。</li></ul><p>总而言之，在ES6之前，JS 的确可以通过各种操作模拟类似于类的行为，但最终实现的代码显得非常冗长和杂乱，这也正是ES6 推出类（class) 这个语法糖结构的必要性所在。但同时需要指明的是，class背后使用的仍然是原型和构造函数的概念。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>类型继承</tag>
      
      <tag>原型</tag>
      
      <tag>寄生式组合继承</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>幽灵依赖与包管理工具</title>
    <link href="/2023/05/05/pnpm/"/>
    <url>/2023/05/05/pnpm/</url>
    
    <content type="html"><![CDATA[<h2 id="包管理工具"><a href="#包管理工具" class="headerlink" title="包管理工具"></a>包管理工具</h2><p>最近接触了 vben-admin 这个开源项目，发现使用的包管理工具是 pnpm，而我之前一直都是用的 npm，想来不知他们有何差别，便去网上找了些资料和文档学习一下。</p><p>目前流行的包管理工具：npm，yarn，pnpm。pnpm的主要优势在于节省磁盘空间，install命令执行速度快，解决了幽灵依赖。</p><h2 id="node-modules-的目录结构"><a href="#node-modules-的目录结构" class="headerlink" title="node_modules 的目录结构"></a>node_modules 的目录结构</h2><h3 id="嵌套式"><a href="#嵌套式" class="headerlink" title="嵌套式"></a>嵌套式</h3><p>在早期的npm@2版本中，他的 node_modules 目录是嵌套式的。因此当一个依赖包内部依赖另一个包时，外部的依赖包目录里会再嵌套一层node_modules，里面存放着内部依赖包。</p><p>一个例子，demo-foo 和 demo-baz 都依赖了demo-bar 这个包，它被同时安装在demo-foo和demo-baz的node_modules下。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">node_modules<br>└─ demo-foo<br>   ├─ index.<span class="hljs-keyword">js</span><br><span class="hljs-keyword"></span>   ├─ package.<span class="hljs-keyword">json</span><br><span class="hljs-keyword"></span>   └─ node_modules<br>      └─ demo-<span class="hljs-keyword">bar</span><br><span class="hljs-keyword"></span>         ├─ index.<span class="hljs-keyword">js</span><br><span class="hljs-keyword"></span>         └─ package.<span class="hljs-keyword">json</span><br><span class="hljs-keyword"></span>└─ demo-<span class="hljs-keyword">baz</span><br><span class="hljs-keyword"></span>   ├─ index.<span class="hljs-keyword">js</span><br><span class="hljs-keyword"></span>   ├─ package.<span class="hljs-keyword">json</span><br><span class="hljs-keyword"></span>   └─ node_modules<br>      └─ demo-<span class="hljs-keyword">bar</span><br><span class="hljs-keyword"></span>         ├─ index.<span class="hljs-keyword">js</span><br><span class="hljs-keyword"></span>         └─ package.<span class="hljs-keyword">json</span><br></code></pre></td></tr></table></figure><p>虽然这种方式目录结构比较清晰，但它的缺点显而易见，如果多个依赖包都在内部依赖同一种依赖，由于没有复用机制，会造成磁盘空间的浪费；且如果嵌套层级太深，那么在windows中无法识别长度超过255个字符的路径，造成严重的问题。</p><h3 id="扁平式"><a href="#扁平式" class="headerlink" title="扁平式"></a>扁平式</h3><p>为了解决上述问题，后来的 npm@3+ 版本和新出的 yarn 对 node_modules 目录结构做出了改变，将原来嵌套式的目录结构拍平，所有的依赖包和依赖的依赖都存放在根node_modules目录下，再通过链接的方式，<strong>共享</strong>依赖的依赖。</p><p>跟上一个例子相同的场景，目录结构被拍平了，demo-foo和demo-baz共同依赖同一个demo-bar</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs text">node_modules<br>└─ demo-bar<br>   ├─ index.js<br>   └─ package.json<br>└─ demo-baz<br>   ├─ index.js<br>   └─ package.json<br>└─ demo-foo<br>   ├─ index.js<br>   └─ package.json<br></code></pre></td></tr></table></figure><p>这种方式解决了嵌套式目录路径过长和依赖不能复用的问题。但同时也引入了新的问题：幽灵依赖和分身问题</p><h2 id="幽灵依赖"><a href="#幽灵依赖" class="headerlink" title="幽灵依赖"></a>幽灵依赖</h2><p>幽灵依赖是指：在 JS 代码中可以导入并没有在 <code>package.json </code>中出现的包。这是扁平化的node_modules目录引起的，它把所有的依赖和子依赖都置于最顶层。根据模块的加载机制，demo-bar即使没有被显式的install，但仍可以通过<code>import bar from &#39;demo-bar&#39;</code>导入这个子依赖。</p><p>幽灵依赖会产生严重的问题：当有一天demo-foo和demo-bar被卸载，那么它们的子依赖也会不复存在，这时项目中引入的demo-bar及其API就会出现问题；再者，当更新父依赖的版本时，它的子依赖的版本也会被更新，一旦这次子依赖的更新导致当前项目中用到的子依赖API失效，那么这个问题是非常难以排查的。</p><h2 id="分身问题"><a href="#分身问题" class="headerlink" title="分身问题"></a>分身问题</h2><p>NPM分身问题是指：对于相同依赖的不同版本，npm只会将其中的一个版本提升到最顶层的node_modules，而剩下的其他版本则可能会被重新安装，并嵌套地安装在父依赖目录下。</p><blockquote><p>具体提升哪个父依赖的相同子依赖，取决于哪个父依赖最早被安装</p></blockquote><p>比如下面这个例子，当某一个其他依赖demo-bar的父依赖C更新版本时，C所需要的demo-bar是1.0.1版本，且C是最早被安装的demo-bar的父依赖，那么1.0.1版本的demo-bar会提升到顶级的node_modules，其他的父依赖重新安装1.0.0版本的demo-bar</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs text">node_modules<br>└─ demo-bar // v1.0.1<br>   ├─ index.js<br>   └─ package.json<br>└─ demo-baz<br>   ├─ index.js<br>   ├─ package.json<br>   └─ node_modules<br>      └─ demo-bar // v1.0.0<br>         ├─ index.js<br>         └─ package.json<br>└─ demo-foo<br>   ├─ index.js<br>   ├─ package.json<br>   └─ node_modules<br>      └─ demo-bar // v1.0.0<br>         ├─ index.js<br>         └─ package.json<br></code></pre></td></tr></table></figure><h2 id="pnpm的解决方案"><a href="#pnpm的解决方案" class="headerlink" title="pnpm的解决方案"></a>pnpm的解决方案</h2><h3 id="硬链接和软链接"><a href="#硬链接和软链接" class="headerlink" title="硬链接和软链接"></a>硬链接和软链接</h3><p>硬链接（hard link）和软连接，又称符号链接（symbolic link）是操作系统中两种共享文件的链接方式。</p><p>硬链接通过直接指向文件的索引块从而实现文件共享；软连接则创建一个新的文件（eg. 快捷方式），文件内容是要共享的文件的硬链接，示意图如下：</p><p><img src="http://182.44.49.100:34/images/2023/05/06/f1e85fbacc206f75936444f322c83c96.png" alt="软链接和硬链接"></p><h3 id="pnpm的目录结构"><a href="#pnpm的目录结构" class="headerlink" title="pnpm的目录结构"></a>pnpm的目录结构</h3><p>pnpm通过软链接、硬链接以及全局依赖库来组织目录结构，从而解决了分身问题和幽灵依赖。</p><p>pnpm将所有的包都安装在全局的 .pnpm-store 目录中（具体路径通过 <code>pnpm store path</code>查询），这是全局依赖库，以下称为store。所有项目的所需依赖都通过硬链接的方式从store链接到node_modules的.pnpm目录中，再用软连接，将.pnpm中的顶层依赖链接到node_modules目录下。</p><p>一个简单的例子：<a href="mailto:&#100;&#101;&#x6d;&#111;&#x2d;&#98;&#97;&#122;&#x40;&#x31;&#46;&#48;&#x2e;&#48;">&#100;&#101;&#x6d;&#111;&#x2d;&#98;&#97;&#122;&#x40;&#x31;&#46;&#48;&#x2e;&#48;</a>和<a href="mailto:&#x64;&#x65;&#x6d;&#x6f;&#45;&#102;&#111;&#111;&#64;&#49;&#x2e;&#x30;&#46;&#49;">&#x64;&#x65;&#x6d;&#x6f;&#45;&#102;&#111;&#111;&#64;&#49;&#x2e;&#x30;&#46;&#49;</a>是经显式install的顶层依赖，demo-bar是它们的子依赖。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs awk">node_modules<br>└─ .pnpm<br>   └─ demo-bar@<span class="hljs-number">1.0</span>.<span class="hljs-number">0</span><br>      └─ node_modules<br>         └─ demo-bar -&gt; &lt;store&gt;/demo-bar<br>   └─ demo-bar@<span class="hljs-number">1.0</span>.<span class="hljs-number">1</span><br>      └─ node_modules<br>         └─ demo-bar -&gt; &lt;store&gt;/demo-bar<br>   └─ demo-baz@<span class="hljs-number">1.0</span>.<span class="hljs-number">0</span><br>      └─ node_modules<br>         ├─ demo-bar -&gt; ..<span class="hljs-regexp">/../</span>demo-bar@<span class="hljs-number">1.0</span>.<span class="hljs-number">0</span><span class="hljs-regexp">/node_modules/</span>demo-bar<br>         └─ demo-baz -&gt; &lt;store&gt;/demo-baz<br>   └─ demo-foo@<span class="hljs-number">1.0</span>.<span class="hljs-number">1</span><br>      └─ node_modules<br>         ├─ demo-bar -&gt; ..<span class="hljs-regexp">/../</span>demo-bar@<span class="hljs-number">1.0</span>.<span class="hljs-number">1</span><span class="hljs-regexp">/node_modules/</span>demo-bar<br>         └─ demo-foo -&gt; &lt;store&gt;/demo-foo<br>└─ demo-baz -&gt; .<span class="hljs-regexp">/pnpm/</span>demo-baz@<span class="hljs-number">1.0</span>.<span class="hljs-number">0</span><span class="hljs-regexp">/node_modules/</span>demo-baz<br>└─ demo-foo -&gt; .<span class="hljs-regexp">/pnpm/</span>demo-foo@<span class="hljs-number">1.0</span>.<span class="hljs-number">1</span><span class="hljs-regexp">/node_modules/</span>demo-foo<br></code></pre></td></tr></table></figure><p>好处：</p><ul><li>.pnpm目录中采用硬链接，所以可以达到包复用的目的</li><li>.pnpm中依赖的node_modules中采用的仍然是扁平式目录，无论demo-foo中嵌套多少层子依赖，它的文件目录的深度依然不变</li><li>由于顶层依赖中没有了子依赖，所以就避免了幽灵依赖</li><li>不同版本的相同子依赖都会存在于顶层.pnpm下，因此某个依赖更新子依赖并不会影响其他依赖的子依赖，依然可以通过硬链接实现依赖的复用，这就解决了分身问题。</li></ul><h2 id="pnpm的局限性"><a href="#pnpm的局限性" class="headerlink" title="pnpm的局限性"></a>pnpm的局限性</h2><ol><li>由于符号连接（symbolic link）在一些场景下有兼容性问题，目前在 Eletron 以及 labmda 部署的应用上无法使用 pnpm</li><li>由于全局公用同一份store，因此当某个项目修改node_modules中的内容时，会直接影响全局store中对应的内容，这会对其他的项目造成影响。关于这个问题，最好的解决方法是clone（copy-on-write写入前复制）：修改前，创建一个新的引用指向当前的文件。</li><li>并不是所有的命令pnpm都很快，例如pnpm run 就比较慢 </li></ol>]]></content>
    
    
    <categories>
      
      <category>前端工程化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pnpm</tag>
      
      <tag>幽灵依赖</tag>
      
      <tag>包管理工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>事件循环和消息队列(三)</title>
    <link href="/2023/05/05/broswerQuestions/"/>
    <url>/2023/05/05/broswerQuestions/</url>
    
    <content type="html"><![CDATA[<h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><h2 id="浏览器是如何渲染页面的？"><a href="#浏览器是如何渲染页面的？" class="headerlink" title="浏览器是如何渲染页面的？"></a>浏览器是如何渲染页面的？</h2><p>当浏览器的网络线程收到 HTML 文档后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列。</p><p>在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染流程。</p><hr><p>整个渲染流程分为多个阶段，分别是： HTML 解析、样式计算、布局、分层、绘制、分块、光栅化、画</p><p>每个阶段都有明确的输入输出，上一个阶段的输出会成为下一个阶段的输入。</p><p>这样，整个渲染流程就形成了一套组织严密的生产流水线。</p><hr><p>渲染的第一步是<strong>解析 HTML</strong>。</p><p>解析过程中遇到 CSS 解析 CSS，遇到 JS 执行 JS。为了提高解析效率，浏览器在开始解析前，会启动一个预解析的线程，率先下载 HTML 中的外部 CSS 文件和 外部的 JS 文件。</p><p>如果主线程解析到<code>link</code>位置，此时外部的 CSS 文件还没有下载解析好，主线程不会等待，继续解析后续的 HTML。这是因为下载和解析 CSS 的工作是在预解析线程中进行的。这就是 CSS 不会阻塞 HTML 解析的根本原因。</p><p>如果主线程解析到<code>script</code>位置，会停止解析 HTML，转而等待 JS 文件下载好，并将全局代码解析执行完成后，才能继续解析 HTML。这是因为 JS 代码的执行过程可能会修改当前的 DOM 树，所以 DOM 树的生成必须暂停。这就是 JS 会阻塞 HTML 解析的根本原因。</p><p>第一步完成后，会得到 DOM 树和 CSSOM 树，浏览器的默认样式、内部样式、外部样式、行内样式均会包含在 CSSOM 树中。</p><hr><p>渲染的下一步是<strong>样式计算</strong>。</p><p>主线程会遍历得到的 DOM 树，依次为树中的每个节点计算出它最终的样式，称之为 Computed Style。</p><p>在这一过程中，很多预设值会变成绝对值，比如<code>red</code>会变成<code>rgb(255,0,0)</code>；相对单位会变成绝对单位，比如<code>em</code>会变成<code>px</code></p><p>这一步完成后，会得到一棵带有样式的 DOM 树。</p><hr><p>接下来是<strong>布局</strong>，布局完成后会得到布局树。</p><p>布局阶段会依次遍历 DOM 树的每一个节点，计算每个节点的几何信息。例如节点的宽高、相对包含块的位置。</p><p>大部分时候，DOM 树和布局树并非一一对应。</p><p>比如<code>display:none</code>的节点没有几何信息，因此不会生成到布局树；又比如使用了伪元素选择器，虽然 DOM 树中不存在这些伪元素节点，但它们拥有几何信息，所以会生成到布局树中。还有匿名行盒、匿名块盒等等都会导致 DOM 树和布局树无法一一对应。</p><hr><p>下一步是<strong>分层</strong></p><p>主线程会使用一套复杂的策略对整个布局树中进行分层。</p><p>分层的好处在于，将来某一个层改变后，仅会对该层进行后续处理，从而提升效率。</p><p>滚动条、堆叠上下文、transform、opacity 等样式都会或多或少的影响分层结果，也可以通过<code>will-change</code>属性更大程度的影响分层结果。</p><hr><p>再下一步是<strong>绘制</strong></p><p>主线程会为每个层单独产生绘制指令集，用于描述这一层的内容该如何画出来。</p><hr><p>完成绘制后，主线程将每个图层的绘制信息提交给合成线程，剩余工作将由合成线程完成。</p><p>合成线程首先对每个图层进行分块，将其划分为更多的小区域。</p><p>它会从线程池中拿取多个线程来完成分块工作。</p><hr><p>分块完成后，进入<strong>光栅化</strong>阶段。</p><p>合成线程会将块信息交给 GPU 进程，以极高的速度完成光栅化。</p><p>GPU 进程会开启多个线程来完成光栅化，并且优先处理靠近视口区域的块。</p><p>光栅化的结果，就是一块一块的位图</p><hr><p>最后一个阶段就是<strong>画</strong>了</p><p>合成线程拿到每个层、每个块的位图后，生成一个个「指引（quad）」信息。</p><p>指引会标识出每个位图应该画到屏幕的哪个位置，以及会考虑到旋转、缩放等变形。</p><p>变形发生在合成线程，与渲染主线程无关，这就是<code>transform</code>效率高的本质原因。</p><p>合成线程会把 quad 提交给 GPU 进程，由 GPU 进程产生系统调用，提交给 GPU 硬件，完成最终的屏幕成像。</p><h2 id="什么是-reflow？"><a href="#什么是-reflow？" class="headerlink" title="什么是 reflow？"></a>什么是 reflow？</h2><p>reflow 的本质就是重新计算 layout 树。</p><p>当进行了会影响布局树的操作后，需要重新计算布局树，会引发 layout。</p><p>为了避免连续的多次操作导致布局树反复计算，浏览器会合并这些操作，当 JS 代码全部完成后再进行统一计算。所以，改动属性造成的 reflow 是异步完成的。</p><p>也同样因为如此，当 JS 获取布局属性时，就可能造成无法获取到最新的布局信息。</p><p>浏览器在反复权衡下，最终决定获取属性立即 reflow。</p><h2 id="什么是-repaint？"><a href="#什么是-repaint？" class="headerlink" title="什么是 repaint？"></a>什么是 repaint？</h2><p>repaint 的本质就是重新根据分层信息计算了绘制指令。</p><p>当改动了可见样式后，就需要重新计算，会引发 repaint。</p><p>由于元素的布局信息也属于可见样式，所以 reflow 一定会引起 repaint。</p><h2 id="为什么-transform-的效率高？"><a href="#为什么-transform-的效率高？" class="headerlink" title="为什么 transform 的效率高？"></a>为什么 transform 的效率高？</h2><p>因为 transform 既不会影响布局也不会影响绘制指令，它影响的只是渲染流程的最后一个「draw」阶段</p><p>由于 draw 阶段在合成线程中，所以 transform 的变化几乎不会影响渲染主线程。反之，渲染主线程无论如何忙碌，也不会影响 transform 的变化。</p><h2 id="如何理解-JS-的异步？"><a href="#如何理解-JS-的异步？" class="headerlink" title="如何理解 JS 的异步？"></a>如何理解 JS 的异步？</h2><p>JS是一门单线程的语言，这是因为它运行在浏览器的渲染主线程中，而渲染主线程只有一个。</p><p>而渲染主线程承担着诸多的工作，渲染页面、执行 JS 都在其中运行。</p><p>如果使用同步的方式，就极有可能导致主线程产生阻塞，从而导致消息队列中的很多其他任务无法得到执行。这样一来，一方面会导致繁忙的主线程白白的消耗时间，另一方面导致页面无法及时更新，给用户造成卡死现象。</p><p>所以浏览器采用异步的方式来避免。具体做法是当某些任务发生时，比如计时器、网络、事件监听，主线程将任务交给其他线程去处理，自身立即结束任务的执行，转而执行后续代码。当其他线程完成时，将事先传递的回调函数包装成任务，加入到消息队列的末尾排队，等待主线程调度执行。</p><p>在这种异步模式下，浏览器永不阻塞，从而最大限度的保证了单线程的流畅运行。</p><blockquote><p>何为异步？</p><p>代码在执行过程中，会遇到一些无法立即处理的任务，比如：</p><ul><li>计时完成后需要执行的任务 —— <code>setTimeout</code>、<code>setInterval</code>  （交给计时线程去计时）</li><li>网络通信完成后需要执行的任务 – <code>XHR</code>、<code>Fetch </code>  （交给网络进程去请求）</li><li>用户操作后需要执行的任务 – <code>addEventListener</code>   （交给交互线程去时时刻刻地监听事件）</li></ul><p>如果让渲染主线程等待这些任务的时机达到，就会导致主线程长期处于「阻塞」的状态，从而导致浏览器「卡死」</p><p><strong>渲染主线程承担着极其重要的工作，无论如何都不能阻塞！</strong>因此，浏览器选择<strong>异步</strong>来解决这个问题</p></blockquote><h2 id="JS-为何会阻碍渲染？"><a href="#JS-为何会阻碍渲染？" class="headerlink" title="JS 为何会阻碍渲染？"></a>JS 为何会阻碍渲染？</h2><p>JS 代码和渲染任务都在主线程中执行，如果当前任务中的 JS 代码发生阻塞，那么任务队列中的渲染任务就被阻碍了。</p><h2 id="任务有优先级吗？"><a href="#任务有优先级吗？" class="headerlink" title="任务有优先级吗？"></a>任务有优先级吗？</h2><p>任务没有优先级，在消息队列中先进先出</p><p>但<strong>消息队列是有优先级的</strong></p><p>根据 W3C 的最新解释:</p><ul><li>每个任务都有一个任务类型，同一个类型的任务必须在一个队列，不同类型的任务可以分属于不同的队列。<br>在一次事件循环中，浏览器可以根据实际情况从不同的队列中取出任务执行。</li><li>浏览器必须准备好一个微队列，微队列中的任务优先所有其他任务执行<br><a href="https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint">https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint</a></li></ul><blockquote><p>随着浏览器的复杂度急剧提升，W3C 不再使用宏队列的说法</p></blockquote><p>在目前 chrome 的实现中，至少包含了下面的队列：</p><ul><li>延时队列：用于存放计时器到达后的回调任务，优先级「中」</li><li>交互队列：用于存放用户操作后产生的事件处理任务，优先级「高」</li><li>微队列：用户存放需要最快执行的任务，优先级「最高」</li></ul><h2 id="阐述一下-JS-的事件循环？"><a href="#阐述一下-JS-的事件循环？" class="headerlink" title="阐述一下 JS 的事件循环？"></a>阐述一下 JS 的事件循环？</h2><p>事件循环又叫做消息循环，是浏览器渲染主线程的工作方式。</p><p>在 Chrome 的源码中，渲染主线程的最开始会开启一个不会结束的 for 循环，每次循环从消息队列中取出第一个任务执行，而其他线程只需要在合适的时候将任务加入到队列末尾即可。</p><p>过去把消息队列简单分为宏队列和微队列，这种说法目前已无法满足复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式。</p><p>根据 W3C 官方的解释，每个任务有不同的类型，同类型的任务必须在同一个队列，不同的任务可以属于不同的队列。不同任务队列有不同的优先级，在一次事件循环中，由浏览器自行决定取哪一个队列的任务。但浏览器必须有一个微队列，微队列的任务一定具有最高的优先级，必须优先调度执行。</p><h2 id="JS-中的计时器能做到精准计时吗？"><a href="#JS-中的计时器能做到精准计时吗？" class="headerlink" title="JS 中的计时器能做到精准计时吗？"></a>JS 中的计时器能做到精准计时吗？</h2><p>不行，因为：</p><ol><li>计算机硬件没有原子钟，无法做到精确计时</li><li>操作系统的计时函数本身就有少量偏差，由于 JS 的计时器最终调用的是操作系统的函数，也就携带了这些偏差</li><li>按照 W3C 的标准，浏览器实现计时器时，如果嵌套层级超过 5 层，则会带有 4 毫秒的最少时间，这样在计时时间少于 4 毫秒时又带来了偏差</li><li>受事件循环的影响，计时器的回调函数只能在主线程空闲时运行，因此又带来了偏差</li></ol>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器原理</tag>
      
      <tag>事件循环</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue2电商练手项目</title>
    <link href="/2023/04/09/shop-app/"/>
    <url>/2023/04/09/shop-app/</url>
    
    <content type="html"><![CDATA[<p><em>完成了一个 Vue2 的的练手项目，记录部分项目开发流程和技术点</em></p><h3 id="创建-Vue-项目"><a href="#创建-Vue-项目" class="headerlink" title="创建 Vue 项目"></a>创建 Vue 项目</h3><ul><li>创建vue项目：在根目录cmd <code>vue create xxx</code></li><li>创建vue项目时就勾上Router，免得开发时再手动安装 vue-router 插件包。同理把 css preprocess也勾选上，免得手动安装 less loader 包</li></ul><h3 id="eslint常见报错类型"><a href="#eslint常见报错类型" class="headerlink" title="eslint常见报错类型"></a>eslint常见报错类型</h3><ul><li>组件的命名必须是<strong>多个</strong>单词的驼峰命名</li><li>组件通过 <code>import</code> 引入后必须注册，注册后必须使用，变量、方法同理</li><li><code>import</code> 引入组件的文件时<strong>不能</strong>带上 .vue 后缀</li></ul><h3 id="文件树规范"><a href="#文件树规范" class="headerlink" title="文件树规范"></a>文件树规范</h3><ul><li><p>node_modules 是包裹项目依赖的各个包的文件夹</p></li><li><p>public 中存放的是<strong>静态页面</strong> index.html （vue和react一般用来开发单页面应用，单页面应用自然要有一个html文件）和一些<strong>静态资源</strong>（图片）。放在public文件夹的资源在 webpack 打包时会原封不动的放到dist文件夹中</p></li><li><p>src 意为<strong>源码</strong>，顾名思义该目录是开发者写代码的文件夹</p><ul><li>assets 也是放置<strong>静态资源</strong>（一般放置多个组件共用的静态资源）。与 public 不同的是，放置在 assets 文件夹中的静态资源，在webpack打包时会被当做一个模块，打包在 js 文件里</li><li>components 一般放置的是<strong>非路由组件</strong>（全局组件），不管跳转到哪个 page 页面上都会有的组件，通常以 html 标签的方式使用</li><li>pages 放置<strong>路由组件</strong>，即经路由跳转到的组件，通常用 <code>router-view</code> 来使用</li><li>router 项目当中配置的<strong>路由‘器’</strong>放置在 router 文件夹中。</li><li>App.vue 是项目中的<strong>唯一根组件</strong></li><li>main.js 是程序的入口文件，也是整个程序当中最先执行的文件</li></ul></li><li><p>babel.config.js 是 babel 的配置文件。可以把 babel 理解为翻译官，负责把 ES6 语法翻译为 ES5 兼容性更好</p></li><li><p>vue.confg.js 是 vue 项目的可选配置文件，运行时会被自动加载。用于配置打包dist文件夹的路径、webpack、Babel、eslint的设置等等，详见<a href="https://links.jianshu.com/go?to=https://cli.vuejs.org/zh/config/%23">https://cli.vuejs.org/zh/config/#</a></p></li><li><p>package.json 可以理解为是项目的身份证，记录着项目的信息（项目叫什么，版本是多少，运行脚本是什么，依赖有哪些）</p></li><li><p>package-lock.json 缓存性文件，告诉我项目的依赖包是从哪里下载的</p></li><li><p>readme.md 说明性的文件</p></li></ul><h3 id="路由相关"><a href="#路由相关" class="headerlink" title="路由相关"></a>路由相关</h3><p><strong>使用路由的流程</strong></p><p>​        在 index.js 引入 vue-router 插件 <strong>=&gt;</strong> Vue.use() 注册引用的插件 <strong>=&gt;</strong> 定义路由配置 <strong>=&gt;</strong> 在main.js中引入定好的路由 <strong>=&gt;</strong> 把引入的路由作为根组件的选项添加进去。</p><ul><li><p>前端的路由表现为 url : component 的键值对，这种 component 被称为路由组件。</p></li><li><p>在使用时一定要<strong>注册路由</strong>：在 main.js 中用 <code>import router from &#39;@/router/index.js&#39; </code> 引入 <code>router</code> ，并将其添加到 Vue 根组件的选项上。</p></li><li><p>注册完路由，会发生神奇的事情，不管是非路由组件还是路由组件，他们身上都会获得 <code>$route</code> 和 <code>$router</code> 属性。<code>$route</code> ：一般获取<strong>路由信息</strong>（路径、query、params，meta），<code>$router</code> 是<strong>路由操作</strong>对象，用于实现编程式导航进行路由跳转（push | replace）。</p></li><li><p><strong>路由重定向</strong><code>&#123;path: &#39;/&#39;, redirect: &#39;/home&#39;&#125;  </code> ，打开域名直接跳转到首页</p></li><li><p>路由的跳转分两种：</p><ul><li><p>声明式导航，用 <code>router-link</code> 代替 <code>&lt;a&gt;...&lt;/a&gt;</code> 用户点击，直接进行路由跳转    </p></li><li><p>编程式导航，用 <code>$router.push()</code> 和 <code>$router.replace()</code> 进行路由跳转。比如，用户点击登录时，我们不希望直接进行跳转，而是先进行账户验证后再发生跳转。  在跳转发生前后做一些动作，这就是编程式导航的典型应用场景</p></li></ul></li><li><p>路由重定向：将一个 url 重定向为指向另一个 url。</p></li><li><p><strong>路由元信息</strong>：他是一个Object。有时，你可能希望将任意<strong>信息附加</strong>到路由上，如过渡名称、谁可以访问路由、在该路由下那些组件隐藏等。这些事情可以通过接收属性对象的<code>meta</code>属性来实现，并且它可以在路由地址和导航守卫上都被访问到。</p></li><li><p><strong>路由传参</strong>分两种：</p><ul><li>params参数：实现<strong>动态路由</strong>，必须在路由的 path 处添加 <code>:/xxx</code> 的占位符。<ul><li>当路由的path里设置了占位符，默认是必须传 params 参数的。如果路由跳转时却没有提供 params 参数，则跳转后的 url 中就会有 url 路径缺失的现象，这当然不是我们希望看到的。所以，尽量在路由中定义占位符时加上一个问号 <code>:/xxx?</code> 代表着 params 参数可传可不传。</li></ul></li><li>query参数：即<code>path?xxx=1&amp;xxx=2</code>这样用于搜索的参数。</li></ul><blockquote><p>当需要路由传参时，推荐使用命名路由的name进行路由检索，当然这<strong>只能</strong>用于push的<strong>对象参数</strong>（另一种原始的参数是字符串参数）。</p><p>另外要注意：push的对象参数里，path 和 params是<strong>不可同时使用</strong>的，如果要传params，必须用name来指定路由</p></blockquote><ul><li>给<strong>路由组件传递props</strong>：在路由定义处设置，常用函数式传递，既能传递 params 和query参数又能传递自定义数据。</li></ul></li></ul><h3 id="页面组件结构"><a href="#页面组件结构" class="headerlink" title="页面组件结构"></a>页面组件结构</h3><p>典型的上中下结构</p><p><img src="http://182.44.49.100:34/images/2023/05/06/99a042307be2e6e58cd703214d0c07a4.png" alt="组件结构"></p><h3 id="技术点"><a href="#技术点" class="headerlink" title="技术点"></a>技术点</h3><p><img src="http://182.44.49.100:34/images/2023/05/06/7801634e91006adb2b0a329401f8cbba.png" alt="技术点"></p>]]></content>
    
    
    <categories>
      
      <category>vue2</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue2</tag>
      
      <tag>电商项目</tag>
      
      <tag>vuex</tag>
      
      <tag>vue-router</tag>
      
      <tag>mock</tag>
      
      <tag>代理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>事件循环和消息队列（二）</title>
    <link href="/2023/03/30/eventLoop/"/>
    <url>/2023/03/30/eventLoop/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上篇文章中介绍了多进程的浏览器基本架构，现在，我们来谈谈单线程的 JS 代码、消息队列、事件循环、微任务和宏任务。</p><h2 id="单线程的-JavaScript"><a href="#单线程的-JavaScript" class="headerlink" title="单线程的 JavaScript"></a>单线程的 JavaScript</h2><h3 id="JS-代码运行在哪里？"><a href="#JS-代码运行在哪里？" class="headerlink" title="JS 代码运行在哪里？"></a>JS 代码运行在哪里？</h3><p>如果你已经仔细阅读过上一篇文章，那么答案是显而易见的：由于浏览器是由渲染进程的主线程来执行 js 代码的，换句话说，js的运行位置是渲染进程的主线程，所以 js 自然而然就是单线程的。</p><h3 id="js-为什么设计成单线程的？"><a href="#js-为什么设计成单线程的？" class="headerlink" title="js 为什么设计成单线程的？"></a>js 为什么设计成单线程的？</h3><p>这个问题的答案同样在上一篇文章中有所体现。浏览器中的js执行和页面渲染是在同一个线程中发生的，主线程在解析HTML生成DOM树的过程中，如果遇到<code>&lt;script&gt;</code>标签会先执行js代码而阻塞对HTML的解析，因为 js 能够修改DOM进而影响渲染结果。但如果 js 可以拥有多个线程来执行，那么会出现一边解析HTML进行渲染，一边执行的 js 代码操作 DOM ，这样会影响到页面最终渲染效果的一致性（可预见性）。</p><h3 id="同步任务和异步任务"><a href="#同步任务和异步任务" class="headerlink" title="同步任务和异步任务"></a>同步任务和异步任务</h3><ul><li>同步任务：按顺序执行的js代码，上一个任务结束才能执行下一个任务，<strong>主线程中只执行同步任务</strong>。</li><li>异步任务：<strong>不进入主线程</strong>执行，而是由宿主环境提供的线程执行。当<strong>异步任务完成时</strong>，会在消息队列中添加异步任务的回调函数。</li></ul><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>此时，你可能会有疑问：既然 JS 是单线程的，而异步任务又不是在主线程中执行的，这不是矛盾了吗？实际上，JS的确是单线程，但他的宿主环境（浏览器，Node.js）可不是单线程的，js中一些耗时的任务，可以交由宿主环境的其他线程来执行，但这与多线程语言可以开启多个线程并行执行任务并不相同。</p><p>让我们来看看异步任务执行时发生了什么。假设js代码发出了一个异步 http 请求，此时由IO线程来接管执行http请求的代码，主线程将异步任务挂起，并继续执行接下来的同步代码，当IO线程接收到了服务器发来的响应，便将异步任务的回调加入到消息队列的队尾。</p><p><strong>消息队列</strong>（任务队列）是在<strong>主线程之外的数据结构，</strong>每当有异步任务完成，那么他的回调函数（callback）就会被push到消息队列的队尾。主线程中所有同步任务执行完之后，由事件循环来通知主线程开始执行消息队列中的任务。</p><h3 id="事件循环（Event-Loop）"><a href="#事件循环（Event-Loop）" class="headerlink" title="事件循环（Event Loop）"></a>事件循环（Event Loop）</h3><p>简单的说，事件循环起到通知主线程该执行异步任务回调的作用。</p><ol><li>在浏览器源码中，可以看到在最开始的时候，渲染主线程会进入一个无限循环</li><li>每一次循环会检查消息队列中是否有任务存在。如果有，就取出第一个任务执行，执行完一个后进入下一次循环；如果没有，则进入休眠状态。</li><li>其他所有线程（包括其他进程的线程）可以随时向消息队列添加任务。新任务会加到消息队列的末尾。在添加新任务时，如果主线程是休眠状态，则会将其唤醒以继续循环拿取任务</li></ol><p>这样一来，就可以让每个异步任务有条不紊的、持续的进行下去了。</p><p><strong>整个过程，被称之为事件循环（在chrome源码中称为消息循环）</strong></p><p><img src="http://182.44.49.100:34/images/image-20230507175003831.png" alt="image-20230507175003831"></p><h2 id="任务的优先级"><a href="#任务的优先级" class="headerlink" title="任务的优先级"></a>任务的优先级</h2><p>任务没有优先级，在消息队列中先进先出</p><p>但<strong>消息队列是有优先级的</strong></p><p>根据 W3C 的最新解释:</p><ul><li><p>每个任务都有一个任务类型，同一个类型的任务必须在一个队列，不同类型的任务可以分属于不同的队列。<br>在一次事件循环中，浏览器可以根据实际情况从不同的队列中取出任务执行。</p></li><li><p>浏览器必须准备好一个微队列，微队列中的任务优先所有其他任务执行<br><a href="https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint">https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint</a></p><blockquote><p>随着浏览器的复杂度急剧提升，W3C 不再使用宏队列的说法</p></blockquote></li></ul><p>在目前 chrome 的实现中，至少包含了下面的队列：</p><ul><li><p>延时队列：用于存放计时器到达后的回调任务，优先级「<strong>中</strong>」（setTimeout、setInterval）</p></li><li><p>交互队列：用于存放用户操作后产生的事件处理任务，优先级「<strong>高</strong>」（点击事件等交互操作）</p></li><li><p>微队列：用户存放需要最快执行的任务，优先级「<strong>最高</strong>」 （Promise , MutationObserver）</p></li></ul><p>下面用一组图片来形象地展示消息队列和事件循环、异步任务的运行机制：</p><p>没有异步任务时，主线程的一次执行</p><p><img src="http://182.44.49.100:34/images/2023/05/06/image-20230330211730822.png" alt="image-20230330211730822"></p><p>在主线程中引入事件循环</p><p><img src="http://182.44.49.100:34/images/2023/05/06/image-20230330211813118.png" alt="image-20230330211813118"></p><p>渲染进程的线程之间发送通知</p><p><img src="http://182.44.49.100:34/images/2023/05/06/image-20230330211910974.png" alt="image-20230330211910974"></p><p><img src="http://182.44.49.100:34/images/2023/05/06/image-20230330211933941.png" alt="image-20230330211933941"></p><p>线程模型：消息队列、事件循环和跨进程发送信息</p><p><img src="http://182.44.49.100:34/images/2023/05/06/image-20230330212109012.png" alt="image-20230330212109012"></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://juejin.cn/post/7073099307510923295">阿里一面：熟悉事件循环？那谈谈为什么会分为宏任务和微任务。</a></p><p><a href="https://juejin.cn/post/6844904193367474184">浅谈浏览器架构、单线程js、事件循环、消息队列、宏任务和微任务</a></p>]]></content>
    
    
    <categories>
      
      <category>浏览器原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>事件循环</tag>
      
      <tag>消息队列</tag>
      
      <tag>微队列</tag>
      
      <tag>交互队列</tag>
      
      <tag>延时队列</tag>
      
      <tag>异步任务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>事件循环和消息队列（一）</title>
    <link href="/2023/03/29/Broswer/"/>
    <url>/2023/03/29/Broswer/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在讲述事件循环和消息队列之前，需要了解 JS 的单线程执行机制，JS 的执行是从上到下依次执行的，这些便是同步任务，而 ES6 引入了 Promise 对象，使得异步任务开始频频出现在 JS 的代码中。</p><p>异步任务不同于顺序执行的同步任务，他对于 JS 运行时来说是一个黑盒，无法预知他究竟什么时候会被执行，因为这取决于异步任务何时从消息队列中出队执行，而消息队列中的异步任务是否出队，则与事件循环机制直接相关。</p><h1 id="从多进程-process-和单线程-thread-谈起"><a href="#从多进程-process-和单线程-thread-谈起" class="headerlink" title="从多进程(process)和单线程(thread)谈起"></a>从多进程(process)和单线程(thread)谈起</h1><p>人们使用的现代浏览器都是多进程的应用程序，而运行在浏览器上的 JS 代码是单线程的。</p><h2 id="浅谈Chrome浏览器架构"><a href="#浅谈Chrome浏览器架构" class="headerlink" title="浅谈Chrome浏览器架构"></a>浅谈Chrome浏览器架构</h2><p>​    如果自己设计一个浏览器，浏览器可以是哪种架构呢？</p><ul><li>单进程架构（线程间进行通信）</li><li>多进程架构（进程间 IPC (Inter-Process Communication)通信）</li></ul><p>如果你的浏览器要以单进程架构进行设计，需要在一个进程内实现网络、调度、存储、IO设备、渲染、插件等任务，当然你可以把这些任务分为若干个线程去执行，形成单进程多线程的浏览器架构。</p><p>但是由于这些任务在现在操作系统中越来越复杂，例如把网络、存储、渲染这些任务放在一个线程中，执行效率和性能越来越低下（比如有一些网页的代码存在内存泄露，即便关闭这些网页线程，进程中的这块内存也无法被回收，除非关闭浏览器，否则越用越卡），且无法再向下拆分出类似线程的子空间，因为线程已经是最小的执行单位。</p><p>因此，为了强化浏览器的各个复杂功能，出现了多进程架构的浏览器，可以将网络、存储、渲染、IO、插件这些复杂任务分配给一个个单独的进程，这样每个进程又能向下拆分出多个线程，极大程度上强化了浏览器。</p><h3 id="理解Chrome的多进程架构"><a href="#理解Chrome的多进程架构" class="headerlink" title="理解Chrome的多进程架构"></a>理解Chrome的多进程架构</h3><p>Chrome也是基于多进程架构的现代浏览器，Chrome的主要进程组成如下：</p><p><img src="http://182.44.49.100:34/images/2023/05/06/image-20230329211758826.png" alt="image-20230329211758826"></p><ul><li><p>Browser 进程：Tab之外的一切都有该进程处理。负责地址栏、书签栏、前进后退、网络请求、文件访问等；</p></li><li><p>Renderer 进程：负责一个 Tab 内所有和网页渲染有关的事情，是最核心的进程；</p></li><li><p>Plugin 进程：负责 Chrome 插件相关的任务；</p></li><li><p>GPU 进程：GPU进程与其他浏览器进程相隔离处理GPU任务，把浏览器的页面内容绘制到屏幕上；</p><blockquote><p>所有应用程序都要在OS的调度下基于CPU和GPU的计算才能运行。因为GPU要处理多个应用程序的的请求，浏览器的的GPU进程只是一个分量。GPU擅长处理图形，因此提供GPU计算的应用程序可以实现快速渲染和平滑交互。</p></blockquote></li></ul><p><img src="http://182.44.49.100:34/images/2023/05/06/image-20230329214757221.png" alt="image-20230329214757221"></p><p>Chrome 的每一个Tab 选项卡都拥有自己的 Renderer 进程，有三个 Tab 就意味着有三个不同的 Renderer 进程这样可以保证多个 Tab 之间互不影响，即使其中一个 Tab 没有响应，也不影响其他 Tab 的正常执行。然而，由于进程是 OS 中拥有资源的独立单位，多个 Tab 之间的数据是非共享的，这也意味着多个 Tab 都会有相同的 V8引擎初始化数据，这意味着更多的内存使用。</p><p><img src="http://182.44.49.100:34/images/2023/05/06/image-20230329220338191.png" alt="image-20230329220338191"></p><h3 id="了解-Browser-浏览器进程"><a href="#了解-Browser-浏览器进程" class="headerlink" title="了解 Browser 浏览器进程"></a>了解 Browser 浏览器进程</h3><p>简单来说，在浏览器中，Tab之外的一切都归浏览器进程所接管，它包含3个主要的线程：</p><ul><li>UI thread UI线程：负责绘制和管理浏览器的按钮和输入框区域。</li><li>Network thread 网络线程：负责处理网络堆栈以从互联网接收数据</li><li>Storage thread 存储线程：负责控制文件访问 </li></ul><p>而根据浏览器的优化策略，这三个线程往往会独立为三个进程。</p><p>现在让我们来模拟一个在地址栏输入网址，并将网页呈现在浏览器上的过程</p><ol><li><p>用户在地址栏中键入字符串，UI 线程会识别该字符串是 URL 还是搜索关键词。</p><blockquote><p>Chrome中的地址既可以访问网页，同时又是个搜索框，这里假设我们输入的是 URL。</p></blockquote></li><li><p>UI 线程通知网络线程开始进行导航，发起网络请求</p></li><li><p>读取响应数据，如果响应的是 HTML 文件，那么下一步会将该数据传递给渲染进程；但如果响应数据是一个压缩包或其它类型的文件，那么就意味着我们发送的是下载请求，所以需要把数据传递给下载管理器</p></li><li><p>UI线程负责找到渲染进程，通知它要进行网页渲染</p></li><li><p>此时数据和渲染进程都已经准备好，浏览器进程和渲染进程开启 IPC 传递数据，导航部分完成，你会发现tab由原网页台跳转到空白页面，然后开始边传输HTML 边进行网页渲染。</p></li></ol><h3 id="了解最为重要的-Renderer-渲染进程"><a href="#了解最为重要的-Renderer-渲染进程" class="headerlink" title="了解最为重要的 Renderer 渲染进程"></a>了解最为重要的 Renderer 渲染进程</h3><p>渲染进程主要包括4个线程：</p><ul><li>Main thread 主线程：执行JS、下载资源、计算样式、进行布局、绘制合成</li><li>Raster thread 光栅线程</li><li>Compositor thread 合成线程</li><li>Worker thread 工作者线程</li></ul><h4 id="主线程的功能"><a href="#主线程的功能" class="headerlink" title="主线程的功能"></a>主线程的功能</h4><ul><li><p>执行 JS：主线程在遇到 <code>&lt;script&gt;</code> 标签时会阻塞HTML文档的解析，并必须先下载、解析和执行js代码，why？因为 js 可以用 <code>document.write()</code>之类的东西改变 DOM 结构。这就是为什么会暂停HTML的解析，并等待js代码执行完毕后才能恢复。</p></li><li><p>下载外部资源：如果HTML中由需要加载<strong>外部资源</strong>的标签，这在解析HTML构建DOM树之前会由<strong>预加载扫描线程</strong>检测到，并<strong>提前</strong>利用 Browser 线程的 Network 线程来下载<code>&lt;img/&gt;</code>、CSS和 JS的<code>&lt;link&gt;</code>等渲染DOM需要的外部资源文件，这减少了解析 HTML 的阻塞时间</p></li><li><p>解析HTML：由 HTML<strong>解析器</strong>解析 HTML 内容，首先由<strong>分词器</strong>检测出各个标签名，我们称他们为token，然后利用token栈和括号匹配算法，构建出DOM树。同时会根据外部、内部和内联 CSS 样式计算得到 CSSOM 树。</p><p><img src="http://182.44.49.100:34/images/2023/05/06/htmlDOM.png" alt="根据html文档生成DOM树"></p></li><li><p>计算CSS样式：主线程根据 CSSOM 树进行CSS属性值的计算，并将计算后的样式添加到DOM树的对应DOM节点上。</p><blockquote><p>:boat: 计算（最终）样式（computed style）:是把继承、层叠关系理清，并且把所有CSS属性都赋值之后的CSS样式。</p><p>:warning:HTML本质上只是提供了<strong>语义化的标签</strong>。为何div、p标签是块盒，而span标签却是行盒？根本原因是浏览器的源码中，设置了<strong>浏览器默认样式</strong>，而这些标签分别被设置为了<code>display:block </code>和 <code>display:inline</code></p></blockquote></li><li><p>确定<strong>布局</strong>结构<em>Layout</em>：只有DOM节点和和它的样式可不够，还需要确定他们之间的布局关系，并构建与DOM树类似的<strong>布局树</strong>，比如在页面上的位置、盒子的尺寸大小的信息</p><blockquote><p>:label:布局树通常情况下与DOM树结构并不相同。由于布局树只考虑存在位置和尺寸这样的<strong>几何信息</strong>的DOM元素，所以<code>display:none</code>的DOM元素在构建布局树时是不被考虑的，类似的，还有一些伪元素，匿名行盒，匿名块盒…..</p><p>:man_teacher: W3C规定：标签的文本必须被包含在行盒中；行盒和块盒不能相邻。因此用匿名行盒和匿名块盒来适应这个规定</p></blockquote><p><img src="http://182.44.49.100:34/images/2023/05/06/_20230411173336.png" alt="微信截图_20230411173336"></p></li><li><p><strong>分层</strong>（Layer）：主线程会使用一套复杂的策略对整个布局树中进行分层。分层的好处在于，将来某一个层发生改变后，仅会对该层进行后续处理，从而提升效率</p><blockquote><p>滚动条、层叠上下文（z-index）、transform、opacity 等样式都会或多或少的影响分层结果，也可以通过<code>will-change</code>属性更大程度的影响分层结构。</p><p>分层不是越多越好，层数太多会导致占用大量的内存空间，因为浏览器会根据内存和效率权衡分层的数量。</p></blockquote><p><img src="http://182.44.49.100:34/images/2023/05/06/image-20230329230708934.png" alt="image-20230329230708934"></p></li><li><p><strong>计算绘制指令集</strong>（paint）：主线程会为每个层单独产生绘制指令集，用于描述这个层的内容该如何一步步地画出来。完成此步后，主线程将绘制指令集交付给合成线程</p><p><img src="http://182.44.49.100:34/images/2023/05/06/_20230411174231.png" alt="微信截图_20230411174231"></p></li></ul><h4 id="合成器线程"><a href="#合成器线程" class="headerlink" title="合成器线程"></a>合成器线程</h4><p>​    一旦确定了<strong>绘制指令集</strong>，主线程就会将该信息提交给合成器线程。然后，合成线程将对每个层进行分块并光栅化。一个层可以比视口要大，所以合成器线程将它们划分为瓦片（图块），并将每个瓦片发送到GPU进程，完成光栅化，并且在这个过程中优先光栅化靠近视口的区域，紧接着再去光栅化页面的其他区域。（tiling和raster）</p><blockquote><p>将这些信息转换为屏幕上的像素称为光栅化</p></blockquote><p>​    光栅化完成后，GPU进程将生成的位图交回给合成线程，合成线程收到每个层、每个块的位图之后，生成一个个的指引（quad）信息。指引信息会表示出每个位图应该滑到屏幕的那个位置，以及会考虑到旋转、缩放等变形。然后合成线程将 quad 提交给GPU进程，由GPU进程产生系统调用，提交给GPU硬件，完成最终的屏幕成像。（draw）</p><blockquote><p>由于变形操作是在合成线程中执行的，与渲染主线程无关，这就是  transform 效率高的原因</p></blockquote><ul><li>浏览器滚动时，合成线程会创建一个新的合成帧发送给 GPU，以显示到屏幕上，所以即便主线程卡死，也不影响页面滚动。</li><li>合成线程工作与主线程无关，不用等待样式计算和 js 的执行，因此合成线程相关的动画比涉及到主线程重新计算样式和执行 js 的动画更加流畅</li></ul><h4 id="浏览器的渲染过程流程图"><a href="#浏览器的渲染过程流程图" class="headerlink" title="浏览器的渲染过程流程图"></a>浏览器的渲染过程流程图</h4><p><img src="http://182.44.49.100:34/images/2023/05/06/3787d04fe1672d3115116a6d2125f964.png" alt="渲染流程图"></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://developer.chrome.com/blog/inside-browser-part1/">Inside look at modern web browser (part 1)</a></p><p><a href="https://juejin.cn/post/6844904193367474184">浅谈浏览器架构、单线程js、事件循环、消息队列、宏任务和微任务</a></p><p><a href="https://developer.chrome.com/blog/inside-browser-part2/">Inside look at modern web browser (part 2)</a></p><p><a href="https://developer.chrome.com/blog/inside-browser-part3/">Inside look at modern web browser (part 3)</a></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器架构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从0开始在云服务器上搭建Hexo博客</title>
    <link href="/2023/03/20/createBlog/"/>
    <url>/2023/03/20/createBlog/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>​    本来博客是用wordpress在服务器搭建的，但苦于wordpress的后端语言是php，对markdown的支持也不尽如人意，最终还是放弃了wordpress，转战后端为Node的Hexo框架。</p><p>​    <strong>整体思路：</strong></p><ol><li>在服务器上配置Git环境，创建Git仓库</li><li>在主机安装Hexo，并生成Hexo静态文件，通过与服务器链接，将静态文件推送到服务器上的Git仓库</li><li>通过Git-hooks，即Git钩子，实现将服务器Git仓库的文件自动部署到网页资源目录</li><li>将Nginx作为静态文件服务器，实现外界对网页资源目录的访问。</li></ol><p>​    <strong>本文的配置环境为</strong></p><ul><li><p>天翼云服务器：<a href="https://www.bt.cn/new/index.html">宝塔</a>面板，一键安装nginx</p><blockquote><p>没有宝塔可以用ssh链接服务器，敲命令行也是一样的<code>yum install nginx</code></p></blockquote></li><li><p>本地主机：Git、Node.js、Hexo</p><blockquote><p>Hexo安装：<code>npm install hexp -g </code> 。<code>-g</code>意为全局安装。</p><p>如果第一次安装node，请注意配置环境变量，否则会出现<code>hexo不是内部或外部命令</code>的问题。</p></blockquote></li></ul><h3 id="1-在服务器安装Git"><a href="#1-在服务器安装Git" class="headerlink" title="1. 在服务器安装Git"></a>1. 在服务器安装Git</h3><p>​    不管是宝塔提供的终端，还是Xshell的命令行都可以，安装命令<code>yum install git</code>。</p><blockquote><p>安装git可能会出现这样的报错信息</p><p>Loaded plugins: fastestmirror, langpacks</p><p>Loading mirror speeds from cached hostfile</p><p>No package yum-util available.</p><p>Error: Nothing to do</p><p>解决方法可参考：<a href="https://blog.csdn.net/weixin_51225684/article/details/128040380">安装docker时，遇到Loaded plugins…怎么办</a></p></blockquote><h3 id="2-在宝塔面板添加站点"><a href="#2-在宝塔面板添加站点" class="headerlink" title="2.在宝塔面板添加站点"></a>2.在宝塔面板添加站点</h3><p>​    由于天翼云服务器在域名没有备案的情况下不开放80端口，所以手动设置一个空闲的32端口用于访问网页。</p><p><img src="http://182.44.49.100:34/images/2023/05/06/image-20230320213201932.png" alt="image-20230320213201932"></p><p>​    将网站目录设置为如下（自定义即可）</p><p><img src="http://182.44.49.100:34/images/2023/05/06/image-20230320213344566.png" alt="image-20230320213344566"></p><h3 id="3-对服务器的Git进行搭建"><a href="#3-对服务器的Git进行搭建" class="headerlink" title="3.对服务器的Git进行搭建"></a>3.对服务器的Git进行搭建</h3><h4 id="1-添加一个git用户"><a href="#1-添加一个git用户" class="headerlink" title="1. 添加一个git用户"></a>1. 添加一个git用户</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">adduser git       # 添加git用户<br>chmod 740 /etc/sudoers    #改变sudoers文件的权限为文件所有者可写<br>vim /etc/sudoers<br><span class="hljs-meta prompt_">#</span><span class="language-bash">在root ALL=(ALL) ALL下方添加一行,按esc,再按:wq退出编辑</span><br>git ALL=(ALL) ALL<br>chmod 400 /etc/sudoers #将sudoers文件的权限改回文件所有者可读<br><br>sudo passwd git   #设置服务器的git密码，用于git连接。输入时看不到任何显示，输入完成回车即可<br></code></pre></td></tr></table></figure><h4 id="2-给服务器和主机的Git配置SSH密钥"><a href="#2-给服务器和主机的Git配置SSH密钥" class="headerlink" title="2. 给服务器和主机的Git配置SSH密钥"></a>2. 给服务器和主机的Git配置SSH密钥</h4><p>​        如果<strong>主机</strong>已有ssh密钥则跳过这一步，直接到<code>C:\Users\你的用户名\.ssh</code>中找到<code>id_rsa.pub</code>。如果没有，按照如下步骤生成密钥：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">git config --global user.name <span class="hljs-string">&quot;你要设置的名字&quot;</span><br>git config --global user.email <span class="hljs-string">&quot;你要设置的邮箱&quot;</span><br>ssh-keygen -t rsa -C <span class="hljs-string">&quot;你刚刚设置的邮箱&quot;</span><br></code></pre></td></tr></table></figure><p>​        此时<strong>主机</strong>的git密钥已生成，存放在上述<code>id_rsa.pub</code>文件中。接着，打开宝塔的文件管理系统，在<strong>服务器</strong>的<code>/home/git</code>中新建<code>.ssh</code>文件夹，并在其中新建<code>authorized_keys</code>文件。将<strong>主机</strong>的<code>id_rsa.pub</code>中的内容复制到该新建文件中。</p><p><img src="http://182.44.49.100:34/images/2023/05/06/image-20230320211205195.png" alt="image-20230320211205195"></p><p>​        通过配置ssh密钥，主机和服务器的git连接时将不再需要密码，简化了操作。</p><h4 id="3-在服务器中创建一个新的Git仓库"><a href="#3-在服务器中创建一个新的Git仓库" class="headerlink" title="3.在服务器中创建一个新的Git仓库"></a>3.在服务器中创建一个新的Git仓库</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> /home/git<br>git init --bare hexoblog.git  <span class="hljs-comment">#在/home/git下初始化一个名为hexoblog的仓库</span><br></code></pre></td></tr></table></figure><h4 id="4-配置钩子实现自动部署"><a href="#4-配置钩子实现自动部署" class="headerlink" title="4. 配置钩子实现自动部署"></a>4. 配置钩子实现自动部署</h4><p>​    找到<code>/home/git/hexoblog.git/hooks</code>下的<code>post-receive</code>文件，如果没有则新建一个该文件，将其内容改为</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/sh</span><br>git --work-tree=/home/www/mongobin --git-dir=/home/git/hexoblog.git checkout -f<br><br></code></pre></td></tr></table></figure><p>​    以上内容是一条命令，前者为网页资源目录，后者为git仓库。意为当主机将静态文件推给服务器的git仓库后，服务器能够自动将文件部署到网页资源目录。</p><p>​    <strong>然后设置网页资源目录的IO权限，否则git没有权限修改网页资源目录的内容，无法实现自动部署！！！</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo <span class="hljs-built_in">chmod</span> +x /home/git/hexoblog.git/hooks/pre-receive  <span class="hljs-comment">#赋予其可执行权限</span><br>sudo <span class="hljs-built_in">chown</span> -R git:git /home/git/ <span class="hljs-comment">#仓库目录的所有者改为git</span><br>sudo <span class="hljs-built_in">chown</span> -R git:git /home/www/ <span class="hljs-comment">#站点文件夹所有者改为git</span><br></code></pre></td></tr></table></figure><h3 id="4-主机配置与测试"><a href="#4-主机配置与测试" class="headerlink" title="4. 主机配置与测试"></a>4. 主机配置与测试</h3><h4 id="1-在主机初始化博客文件夹并测试本地demo"><a href="#1-在主机初始化博客文件夹并测试本地demo" class="headerlink" title="1. 在主机初始化博客文件夹并测试本地demo"></a>1. 在主机初始化博客文件夹并测试本地demo</h4><p>​    执行以下命令在文件夹中创建一个新的博客文件夹（官方demo）。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> D:\JaBinsProjects\mongobin<br>hexo init<br></code></pre></td></tr></table></figure><p><strong>然后安装两个插件，用于部署，否则会报错！</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">npm install hexo-deployer-git --save<br>npm install hexo-server<br></code></pre></td></tr></table></figure><p>​    执行以下命令即可在本机上查看自己的博客了，地址为<a href="localhost:4000">localhost:4000</a></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo g</span><br><span class="hljs-attribute">hexo s</span><br></code></pre></td></tr></table></figure><p><img src="http://182.44.49.100:34/images/2023/05/06/image-20230320215235929.png" alt="image-20230320215235929"></p><h4 id="2-配置本地博客与服务器git的连接"><a href="#2-配置本地博客与服务器git的连接" class="headerlink" title="2.配置本地博客与服务器git的连接"></a>2.配置本地博客与服务器git的连接</h4><p>​    在刚才生成的博客文件夹根目录中找到并打开<code>_config.yml</code>文件，把最下面的depoly处改为如下内容，目的是与服务器git仓库建立连接。</p><p><img src="http://182.44.49.100:34/images/2023/05/06/image-20230320220031029.png" alt="image-20230320220031029"></p><p>​    <strong>注意：</strong></p><ul><li>type, repo, branch缩进2格</li><li>冒号与其后面的内容必须有一空格</li><li>branch为master和main均可</li></ul><h4 id="3-测试连接和自动部署是否生效"><a href="#3-测试连接和自动部署是否生效" class="headerlink" title="3. 测试连接和自动部署是否生效"></a>3. 测试连接和自动部署是否生效</h4><p>cd到<strong>博客的文件夹下执行</strong>以下命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">hexo new <span class="hljs-string">&quot;Hello My First Blog&quot;</span><br>hexo clean &amp;&amp; hexo generate --deploy<br></code></pre></td></tr></table></figure><p>也可以在<code>package.json</code>中添加<code>npm</code>脚本，简化操作，这样可以直接用<code>npm run dd</code>部署博客网页</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;hexo generate&quot;</span><span class="hljs-punctuation">,</span>   <span class="hljs-comment">// 重新生成静态页面文件</span><br>    <span class="hljs-attr">&quot;clean&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;hexo clean&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-comment">// 清除缓存</span><br>    <span class="hljs-attr">&quot;deploy&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;hexo deploy&quot;</span><span class="hljs-punctuation">,</span>   <span class="hljs-comment">// 将静态页面文件部署到服务器</span><br><span class="hljs-attr">&quot;dd&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;hexo clean &amp;&amp; hexo g -d&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;server&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;hexo server&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;ss&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;hexo clean &amp;&amp; hexo g &amp;&amp; hexo s&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><br></code></pre></td></tr></table></figure><p>然后输入域名<code>www.mongobin.top:32</code>看博客是否更新了一篇文章。</p><h3 id="5-最后"><a href="#5-最后" class="headerlink" title="5.最后"></a>5.最后</h3><p>​    完成部署后可以去<a href="https://hexo.io/themes/">Hexo</a>主题下载自己喜欢的主题，美化博客。现在去本地主机浏览器上输入域名或者公网IP，访问你的博客吧！<br>样例博客：<a href="https://tzy1997.com/">唐志远の博客</a></p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li><p><a href="https://blog.csdn.net/qq_43219561/article/details/116719535">将Hexo部署到云服务器（使用宝塔面板）</a></p></li><li><p><a href="https://blog.csdn.net/weixin_56301399/article/details/129270887">基于云服务器的hexo博客搭建（稳）</a></p></li><li><p><a href="https://blog.csdn.net/u013190417/article/details/122694959">Hexo博客部署至服务器</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Hexo博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>云服务器</tag>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/03/20/hello-world/"/>
    <url>/2023/03/20/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
